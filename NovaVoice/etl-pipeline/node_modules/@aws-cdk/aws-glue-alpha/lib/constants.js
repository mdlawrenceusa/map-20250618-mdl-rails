"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrawlerState = exports.ConditionLogicalOperator = exports.PredicateLogical = exports.MaxCapacity = exports.JobType = exports.Runtime = exports.PythonVersion = exports.JobLanguage = exports.GlueVersion = exports.ExecutionClass = exports.MetricType = exports.JobState = exports.WorkerType = void 0;
/**
 * The type of predefined worker that is allocated when a job runs.
 *
 * If you need to use a WorkerType that doesn't exist as a static member, you
 * can instantiate a `WorkerType` object, e.g: `WorkerType.of('other type')`
 */
var WorkerType;
(function (WorkerType) {
    /**
     * Standard Worker Type
     * 4 vCPU, 16 GB of memory and a 50GB disk, and 2 executors per worker.
     */
    WorkerType["STANDARD"] = "Standard";
    /**
     * G.1X Worker Type
     * 1 DPU (4 vCPU, 16 GB of memory, 64 GB disk), and provides 1 executor per worker. Suitable for memory-intensive jobs.
     */
    WorkerType["G_1X"] = "G.1X";
    /**
     * G.2X Worker Type
     * 2 DPU (8 vCPU, 32 GB of memory, 128 GB disk), and provides 1 executor per worker. Suitable for memory-intensive jobs.
     */
    WorkerType["G_2X"] = "G.2X";
    /**
     * G.4X Worker Type
     * 4 DPU (16 vCPU, 64 GB of memory, 256 GB disk), and provides 1 executor per worker.
     * We recommend this worker type for jobs whose workloads contain your most demanding transforms,
     * aggregations, joins, and queries. This worker type is available only for AWS Glue version 3.0 or later jobs.
     */
    WorkerType["G_4X"] = "G.4X";
    /**
     * G.8X Worker Type
     * 8 DPU (32 vCPU, 128 GB of memory, 512 GB disk), and provides 1 executor per worker. We recommend this worker
     * type for jobs whose workloads contain your most demanding transforms, aggregations, joins, and queries.
     * This worker type is available only for AWS Glue version 3.0 or later jobs.
     */
    WorkerType["G_8X"] = "G.8X";
    /**
     * G.025X Worker Type
     * 0.25 DPU (2 vCPU, 4 GB of memory, 64 GB disk), and provides 1 executor per worker. Suitable for low volume streaming jobs.
     */
    WorkerType["G_025X"] = "G.025X";
    /**
     * Z.2X Worker Type
     */
    WorkerType["Z_2X"] = "Z.2X";
})(WorkerType || (exports.WorkerType = WorkerType = {}));
/**
 * The number of workers of a defined workerType that are allocated when a job runs.
 *
 * @see https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html
 */
/**
 * Job states emitted by Glue to CloudWatch Events.
 *
 * @see https://docs.aws.amazon.com/AmazonCloudWatch/latest/events/EventTypes.html#glue-event-types for more information.
 */
var JobState;
(function (JobState) {
    /**
     * State indicating job run succeeded
     */
    JobState["SUCCEEDED"] = "SUCCEEDED";
    /**
     * State indicating job run failed
     */
    JobState["FAILED"] = "FAILED";
    /**
     * State indicating job run timed out
     */
    JobState["TIMEOUT"] = "TIMEOUT";
    /**
     * State indicating job is starting
     */
    JobState["STARTING"] = "STARTING";
    /**
     * State indicating job is running
     */
    JobState["RUNNING"] = "RUNNING";
    /**
     * State indicating job is stopping
     */
    JobState["STOPPING"] = "STOPPING";
    /**
     * State indicating job stopped
     */
    JobState["STOPPED"] = "STOPPED";
})(JobState || (exports.JobState = JobState = {}));
/**
 * The Glue CloudWatch metric type.
 *
 * @see https://docs.aws.amazon.com/glue/latest/dg/monitoring-awsglue-with-cloudwatch-metrics.html
 */
var MetricType;
(function (MetricType) {
    /**
     * A value at a point in time.
     */
    MetricType["GAUGE"] = "gauge";
    /**
     * An aggregate number.
     */
    MetricType["COUNT"] = "count";
})(MetricType || (exports.MetricType = MetricType = {}));
/**
 * The ExecutionClass whether the job is run with a standard or flexible execution class.
 *
 * @see https://docs.aws.amazon.com/glue/latest/dg/aws-glue-api-jobs-job.html#aws-glue-api-jobs-job-Job
 * @see https://docs.aws.amazon.com/glue/latest/dg/add-job.html
 */
var ExecutionClass;
(function (ExecutionClass) {
    /**
     * The flexible execution class is appropriate for time-insensitive jobs whose start
     * and completion times may vary.
     */
    ExecutionClass["FLEX"] = "FLEX";
    /**
     * The standard execution class is ideal for time-sensitive workloads that require fast job
     * startup and dedicated resources.
     */
    ExecutionClass["STANDARD"] = "STANDARD";
})(ExecutionClass || (exports.ExecutionClass = ExecutionClass = {}));
/**
 * AWS Glue version determines the versions of Apache Spark and Python that are available to the job.
 *
 * @see https://docs.aws.amazon.com/glue/latest/dg/add-job.html.
 */
var GlueVersion;
(function (GlueVersion) {
    /**
     * Glue version using Spark 2.2.1 and Python 2.7
     */
    GlueVersion["V0_9"] = "0.9";
    /**
     * Glue version using Spark 2.4.3, Python 2.7 and Python 3.6
     */
    GlueVersion["V1_0"] = "1.0";
    /**
     * Glue version using Spark 2.4.3 and Python 3.7
     */
    GlueVersion["V2_0"] = "2.0";
    /**
     * Glue version using Spark 3.1.1 and Python 3.7
     */
    GlueVersion["V3_0"] = "3.0";
    /**
     * Glue version using Spark 3.3.0 and Python 3.10
     */
    GlueVersion["V4_0"] = "4.0";
    /**
     * Glue version using Spark 3.5.2 and Python 3.11
     */
    GlueVersion["V5_0"] = "5.0";
})(GlueVersion || (exports.GlueVersion = GlueVersion = {}));
/**
 * Runtime language of the Glue job
 */
var JobLanguage;
(function (JobLanguage) {
    /**
     * Scala
     */
    JobLanguage["SCALA"] = "scala";
    /**
     * Python
     */
    JobLanguage["PYTHON"] = "python";
})(JobLanguage || (exports.JobLanguage = JobLanguage = {}));
/**
 * Python version
 */
var PythonVersion;
(function (PythonVersion) {
    /**
     * Python 2 (the exact version depends on GlueVersion and JobCommand used)
     */
    PythonVersion["TWO"] = "2";
    /**
     * Python 3 (the exact version depends on GlueVersion and JobCommand used)
     */
    PythonVersion["THREE"] = "3";
    /**
     * Python 3.9 (the exact version depends on GlueVersion and JobCommand used)
     */
    PythonVersion["THREE_NINE"] = "3.9";
})(PythonVersion || (exports.PythonVersion = PythonVersion = {}));
/**
 * AWS Glue runtime determines the runtime engine of the job.
 *
 */
var Runtime;
(function (Runtime) {
    /**
     * Runtime for a Glue for Ray 2.4.
     */
    Runtime["RAY_TWO_FOUR"] = "Ray2.4";
})(Runtime || (exports.Runtime = Runtime = {}));
/**
 * The job type.
 *
 * If you need to use a JobType that doesn't exist as a static member, you
 * can instantiate a `JobType` object, e.g: `JobType.of('other name')`.
 */
var JobType;
(function (JobType) {
    /**
     * Command for running a Glue Spark job.
     */
    JobType["ETL"] = "glueetl";
    /**
     * Command for running a Glue Spark streaming job.
     */
    JobType["STREAMING"] = "gluestreaming";
    /**
     * Command for running a Glue python shell job.
     */
    JobType["PYTHON_SHELL"] = "pythonshell";
    /**
     * Command for running a Glue Ray job.
     */
    JobType["RAY"] = "glueray";
})(JobType || (exports.JobType = JobType = {}));
/**
 * The number of AWS Glue data processing units (DPUs) that can be allocated when this job runs. A DPU is a relative measure of processing power that consists of 4 vCPUs of compute capacity and 16 GB of memory.
 */
var MaxCapacity;
(function (MaxCapacity) {
    /**
     * DPU value of 1/16th
     */
    MaxCapacity[MaxCapacity["DPU_1_16TH"] = 0.0625] = "DPU_1_16TH";
    /**
     * DPU value of 1
     */
    MaxCapacity[MaxCapacity["DPU_1"] = 1] = "DPU_1";
})(MaxCapacity || (exports.MaxCapacity = MaxCapacity = {}));
/*
 * Represents the logical operator for combining multiple conditions in the Glue Trigger API.
 */
var PredicateLogical;
(function (PredicateLogical) {
    /**
     * All conditions must be true for the predicate to be true.
     */
    PredicateLogical["AND"] = "AND";
    /**
     * At least one condition must be true for the predicate to be true.
     */
    PredicateLogical["ANY"] = "ANY";
})(PredicateLogical || (exports.PredicateLogical = PredicateLogical = {}));
/**
 * Represents the logical operator for evaluating a single condition in the Glue Trigger API.
 */
var ConditionLogicalOperator;
(function (ConditionLogicalOperator) {
    /** The condition is true if the values are equal. */
    ConditionLogicalOperator["EQUALS"] = "EQUALS";
})(ConditionLogicalOperator || (exports.ConditionLogicalOperator = ConditionLogicalOperator = {}));
/**
 * Represents the state of a crawler for a condition in the Glue Trigger API.
 */
var CrawlerState;
(function (CrawlerState) {
    /** The crawler is currently running. */
    CrawlerState["RUNNING"] = "RUNNING";
    /** The crawler is in the process of being cancelled. */
    CrawlerState["CANCELLING"] = "CANCELLING";
    /** The crawler has been cancelled. */
    CrawlerState["CANCELLED"] = "CANCELLED";
    /** The crawler has completed its operation successfully. */
    CrawlerState["SUCCEEDED"] = "SUCCEEDED";
    /** The crawler has failed to complete its operation. */
    CrawlerState["FAILED"] = "FAILED";
    /** The crawler encountered an error during its operation. */
    CrawlerState["ERROR"] = "ERROR";
})(CrawlerState || (exports.CrawlerState = CrawlerState = {}));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RhbnRzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29uc3RhbnRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBOzs7OztHQUtHO0FBQ0gsSUFBWSxVQTZDWDtBQTdDRCxXQUFZLFVBQVU7SUFDcEI7OztPQUdHO0lBQ0gsbUNBQXFCLENBQUE7SUFFckI7OztPQUdHO0lBQ0gsMkJBQWEsQ0FBQTtJQUViOzs7T0FHRztJQUNILDJCQUFhLENBQUE7SUFFYjs7Ozs7T0FLRztJQUNILDJCQUFhLENBQUE7SUFFYjs7Ozs7T0FLRztJQUNILDJCQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCwrQkFBaUIsQ0FBQTtJQUVqQjs7T0FFRztJQUNILDJCQUFhLENBQUE7QUFDZixDQUFDLEVBN0NXLFVBQVUsMEJBQVYsVUFBVSxRQTZDckI7QUFFRDs7OztHQUlHO0FBRUg7Ozs7R0FJRztBQUNILElBQVksUUFtQ1g7QUFuQ0QsV0FBWSxRQUFRO0lBQ2xCOztPQUVHO0lBQ0gsbUNBQXVCLENBQUE7SUFFdkI7O09BRUc7SUFDSCw2QkFBaUIsQ0FBQTtJQUVqQjs7T0FFRztJQUNILCtCQUFtQixDQUFBO0lBRW5COztPQUVHO0lBQ0gsaUNBQXFCLENBQUE7SUFFckI7O09BRUc7SUFDSCwrQkFBbUIsQ0FBQTtJQUVuQjs7T0FFRztJQUNILGlDQUFxQixDQUFBO0lBRXJCOztPQUVHO0lBQ0gsK0JBQW1CLENBQUE7QUFDckIsQ0FBQyxFQW5DVyxRQUFRLHdCQUFSLFFBQVEsUUFtQ25CO0FBRUQ7Ozs7R0FJRztBQUNILElBQVksVUFVWDtBQVZELFdBQVksVUFBVTtJQUNwQjs7T0FFRztJQUNILDZCQUFlLENBQUE7SUFFZjs7T0FFRztJQUNILDZCQUFlLENBQUE7QUFDakIsQ0FBQyxFQVZXLFVBQVUsMEJBQVYsVUFBVSxRQVVyQjtBQUVEOzs7OztHQUtHO0FBQ0gsSUFBWSxjQVlYO0FBWkQsV0FBWSxjQUFjO0lBQ3hCOzs7T0FHRztJQUNILCtCQUFhLENBQUE7SUFFYjs7O09BR0c7SUFDSCx1Q0FBcUIsQ0FBQTtBQUN2QixDQUFDLEVBWlcsY0FBYyw4QkFBZCxjQUFjLFFBWXpCO0FBRUQ7Ozs7R0FJRztBQUNILElBQVksV0ErQlg7QUEvQkQsV0FBWSxXQUFXO0lBQ3JCOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtJQUVaOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtJQUVaOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtJQUVaOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtJQUVaOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtJQUVaOztPQUVHO0lBQ0gsMkJBQVksQ0FBQTtBQUVkLENBQUMsRUEvQlcsV0FBVywyQkFBWCxXQUFXLFFBK0J0QjtBQUVEOztHQUVHO0FBQ0gsSUFBWSxXQVVYO0FBVkQsV0FBWSxXQUFXO0lBQ3JCOztPQUVHO0lBQ0gsOEJBQWUsQ0FBQTtJQUVmOztPQUVHO0lBQ0gsZ0NBQWlCLENBQUE7QUFDbkIsQ0FBQyxFQVZXLFdBQVcsMkJBQVgsV0FBVyxRQVV0QjtBQUVEOztHQUVHO0FBQ0gsSUFBWSxhQWdCWDtBQWhCRCxXQUFZLGFBQWE7SUFDdkI7O09BRUc7SUFDSCwwQkFBUyxDQUFBO0lBRVQ7O09BRUc7SUFDSCw0QkFBVyxDQUFBO0lBRVg7O09BRUc7SUFDSCxtQ0FBa0IsQ0FBQTtBQUVwQixDQUFDLEVBaEJXLGFBQWEsNkJBQWIsYUFBYSxRQWdCeEI7QUFFRDs7O0dBR0c7QUFDSCxJQUFZLE9BS1g7QUFMRCxXQUFZLE9BQU87SUFDakI7O09BRUc7SUFDSCxrQ0FBdUIsQ0FBQTtBQUN6QixDQUFDLEVBTFcsT0FBTyx1QkFBUCxPQUFPLFFBS2xCO0FBRUQ7Ozs7O0dBS0c7QUFDSCxJQUFZLE9BcUJYO0FBckJELFdBQVksT0FBTztJQUNqQjs7T0FFRztJQUNILDBCQUFlLENBQUE7SUFFZjs7T0FFRztJQUNILHNDQUEyQixDQUFBO0lBRTNCOztPQUVHO0lBQ0gsdUNBQTRCLENBQUE7SUFFNUI7O09BRUc7SUFDSCwwQkFBZSxDQUFBO0FBRWpCLENBQUMsRUFyQlcsT0FBTyx1QkFBUCxPQUFPLFFBcUJsQjtBQUVEOztHQUVHO0FBQ0gsSUFBWSxXQVVYO0FBVkQsV0FBWSxXQUFXO0lBQ3JCOztPQUVHO0lBQ0gsOERBQW1CLENBQUE7SUFFbkI7O09BRUc7SUFDSCwrQ0FBUyxDQUFBO0FBQ1gsQ0FBQyxFQVZXLFdBQVcsMkJBQVgsV0FBVyxRQVV0QjtBQUVEOztHQUVHO0FBQ0gsSUFBWSxnQkFVWDtBQVZELFdBQVksZ0JBQWdCO0lBQzFCOztPQUVHO0lBQ0gsK0JBQVcsQ0FBQTtJQUVYOztPQUVHO0lBQ0gsK0JBQVcsQ0FBQTtBQUNiLENBQUMsRUFWVyxnQkFBZ0IsZ0NBQWhCLGdCQUFnQixRQVUzQjtBQUVEOztHQUVHO0FBQ0gsSUFBWSx3QkFHWDtBQUhELFdBQVksd0JBQXdCO0lBQ2xDLHFEQUFxRDtJQUNyRCw2Q0FBaUIsQ0FBQTtBQUNuQixDQUFDLEVBSFcsd0JBQXdCLHdDQUF4Qix3QkFBd0IsUUFHbkM7QUFFRDs7R0FFRztBQUNILElBQVksWUFrQlg7QUFsQkQsV0FBWSxZQUFZO0lBQ3RCLHdDQUF3QztJQUN4QyxtQ0FBbUIsQ0FBQTtJQUVuQix3REFBd0Q7SUFDeEQseUNBQXlCLENBQUE7SUFFekIsc0NBQXNDO0lBQ3RDLHVDQUF1QixDQUFBO0lBRXZCLDREQUE0RDtJQUM1RCx1Q0FBdUIsQ0FBQTtJQUV2Qix3REFBd0Q7SUFDeEQsaUNBQWlCLENBQUE7SUFFakIsNkRBQTZEO0lBQzdELCtCQUFlLENBQUE7QUFDakIsQ0FBQyxFQWxCVyxZQUFZLDRCQUFaLFlBQVksUUFrQnZCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUaGUgdHlwZSBvZiBwcmVkZWZpbmVkIHdvcmtlciB0aGF0IGlzIGFsbG9jYXRlZCB3aGVuIGEgam9iIHJ1bnMuXG4gKlxuICogSWYgeW91IG5lZWQgdG8gdXNlIGEgV29ya2VyVHlwZSB0aGF0IGRvZXNuJ3QgZXhpc3QgYXMgYSBzdGF0aWMgbWVtYmVyLCB5b3VcbiAqIGNhbiBpbnN0YW50aWF0ZSBhIGBXb3JrZXJUeXBlYCBvYmplY3QsIGUuZzogYFdvcmtlclR5cGUub2YoJ290aGVyIHR5cGUnKWBcbiAqL1xuZXhwb3J0IGVudW0gV29ya2VyVHlwZSB7XG4gIC8qKlxuICAgKiBTdGFuZGFyZCBXb3JrZXIgVHlwZVxuICAgKiA0IHZDUFUsIDE2IEdCIG9mIG1lbW9yeSBhbmQgYSA1MEdCIGRpc2ssIGFuZCAyIGV4ZWN1dG9ycyBwZXIgd29ya2VyLlxuICAgKi9cbiAgU1RBTkRBUkQgPSAnU3RhbmRhcmQnLFxuXG4gIC8qKlxuICAgKiBHLjFYIFdvcmtlciBUeXBlXG4gICAqIDEgRFBVICg0IHZDUFUsIDE2IEdCIG9mIG1lbW9yeSwgNjQgR0IgZGlzayksIGFuZCBwcm92aWRlcyAxIGV4ZWN1dG9yIHBlciB3b3JrZXIuIFN1aXRhYmxlIGZvciBtZW1vcnktaW50ZW5zaXZlIGpvYnMuXG4gICAqL1xuICBHXzFYID0gJ0cuMVgnLFxuXG4gIC8qKlxuICAgKiBHLjJYIFdvcmtlciBUeXBlXG4gICAqIDIgRFBVICg4IHZDUFUsIDMyIEdCIG9mIG1lbW9yeSwgMTI4IEdCIGRpc2spLCBhbmQgcHJvdmlkZXMgMSBleGVjdXRvciBwZXIgd29ya2VyLiBTdWl0YWJsZSBmb3IgbWVtb3J5LWludGVuc2l2ZSBqb2JzLlxuICAgKi9cbiAgR18yWCA9ICdHLjJYJyxcblxuICAvKipcbiAgICogRy40WCBXb3JrZXIgVHlwZVxuICAgKiA0IERQVSAoMTYgdkNQVSwgNjQgR0Igb2YgbWVtb3J5LCAyNTYgR0IgZGlzayksIGFuZCBwcm92aWRlcyAxIGV4ZWN1dG9yIHBlciB3b3JrZXIuXG4gICAqIFdlIHJlY29tbWVuZCB0aGlzIHdvcmtlciB0eXBlIGZvciBqb2JzIHdob3NlIHdvcmtsb2FkcyBjb250YWluIHlvdXIgbW9zdCBkZW1hbmRpbmcgdHJhbnNmb3JtcyxcbiAgICogYWdncmVnYXRpb25zLCBqb2lucywgYW5kIHF1ZXJpZXMuIFRoaXMgd29ya2VyIHR5cGUgaXMgYXZhaWxhYmxlIG9ubHkgZm9yIEFXUyBHbHVlIHZlcnNpb24gMy4wIG9yIGxhdGVyIGpvYnMuXG4gICAqL1xuICBHXzRYID0gJ0cuNFgnLFxuXG4gIC8qKlxuICAgKiBHLjhYIFdvcmtlciBUeXBlXG4gICAqIDggRFBVICgzMiB2Q1BVLCAxMjggR0Igb2YgbWVtb3J5LCA1MTIgR0IgZGlzayksIGFuZCBwcm92aWRlcyAxIGV4ZWN1dG9yIHBlciB3b3JrZXIuIFdlIHJlY29tbWVuZCB0aGlzIHdvcmtlclxuICAgKiB0eXBlIGZvciBqb2JzIHdob3NlIHdvcmtsb2FkcyBjb250YWluIHlvdXIgbW9zdCBkZW1hbmRpbmcgdHJhbnNmb3JtcywgYWdncmVnYXRpb25zLCBqb2lucywgYW5kIHF1ZXJpZXMuXG4gICAqIFRoaXMgd29ya2VyIHR5cGUgaXMgYXZhaWxhYmxlIG9ubHkgZm9yIEFXUyBHbHVlIHZlcnNpb24gMy4wIG9yIGxhdGVyIGpvYnMuXG4gICAqL1xuICBHXzhYID0gJ0cuOFgnLFxuXG4gIC8qKlxuICAgKiBHLjAyNVggV29ya2VyIFR5cGVcbiAgICogMC4yNSBEUFUgKDIgdkNQVSwgNCBHQiBvZiBtZW1vcnksIDY0IEdCIGRpc2spLCBhbmQgcHJvdmlkZXMgMSBleGVjdXRvciBwZXIgd29ya2VyLiBTdWl0YWJsZSBmb3IgbG93IHZvbHVtZSBzdHJlYW1pbmcgam9icy5cbiAgICovXG4gIEdfMDI1WCA9ICdHLjAyNVgnLFxuXG4gIC8qKlxuICAgKiBaLjJYIFdvcmtlciBUeXBlXG4gICAqL1xuICBaXzJYID0gJ1ouMlgnLFxufVxuXG4vKipcbiAqIFRoZSBudW1iZXIgb2Ygd29ya2VycyBvZiBhIGRlZmluZWQgd29ya2VyVHlwZSB0aGF0IGFyZSBhbGxvY2F0ZWQgd2hlbiBhIGpvYiBydW5zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dsdWUvbGF0ZXN0L2RnL2F3cy1nbHVlLWFwaS1qb2JzLWpvYi5odG1sXG4gKi9cblxuLyoqXG4gKiBKb2Igc3RhdGVzIGVtaXR0ZWQgYnkgR2x1ZSB0byBDbG91ZFdhdGNoIEV2ZW50cy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25DbG91ZFdhdGNoL2xhdGVzdC9ldmVudHMvRXZlbnRUeXBlcy5odG1sI2dsdWUtZXZlbnQtdHlwZXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmV4cG9ydCBlbnVtIEpvYlN0YXRlIHtcbiAgLyoqXG4gICAqIFN0YXRlIGluZGljYXRpbmcgam9iIHJ1biBzdWNjZWVkZWRcbiAgICovXG4gIFNVQ0NFRURFRCA9ICdTVUNDRUVERUQnLFxuXG4gIC8qKlxuICAgKiBTdGF0ZSBpbmRpY2F0aW5nIGpvYiBydW4gZmFpbGVkXG4gICAqL1xuICBGQUlMRUQgPSAnRkFJTEVEJyxcblxuICAvKipcbiAgICogU3RhdGUgaW5kaWNhdGluZyBqb2IgcnVuIHRpbWVkIG91dFxuICAgKi9cbiAgVElNRU9VVCA9ICdUSU1FT1VUJyxcblxuICAvKipcbiAgICogU3RhdGUgaW5kaWNhdGluZyBqb2IgaXMgc3RhcnRpbmdcbiAgICovXG4gIFNUQVJUSU5HID0gJ1NUQVJUSU5HJyxcblxuICAvKipcbiAgICogU3RhdGUgaW5kaWNhdGluZyBqb2IgaXMgcnVubmluZ1xuICAgKi9cbiAgUlVOTklORyA9ICdSVU5OSU5HJyxcblxuICAvKipcbiAgICogU3RhdGUgaW5kaWNhdGluZyBqb2IgaXMgc3RvcHBpbmdcbiAgICovXG4gIFNUT1BQSU5HID0gJ1NUT1BQSU5HJyxcblxuICAvKipcbiAgICogU3RhdGUgaW5kaWNhdGluZyBqb2Igc3RvcHBlZFxuICAgKi9cbiAgU1RPUFBFRCA9ICdTVE9QUEVEJyxcbn1cblxuLyoqXG4gKiBUaGUgR2x1ZSBDbG91ZFdhdGNoIG1ldHJpYyB0eXBlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2dsdWUvbGF0ZXN0L2RnL21vbml0b3JpbmctYXdzZ2x1ZS13aXRoLWNsb3Vkd2F0Y2gtbWV0cmljcy5odG1sXG4gKi9cbmV4cG9ydCBlbnVtIE1ldHJpY1R5cGUge1xuICAvKipcbiAgICogQSB2YWx1ZSBhdCBhIHBvaW50IGluIHRpbWUuXG4gICAqL1xuICBHQVVHRSA9ICdnYXVnZScsXG5cbiAgLyoqXG4gICAqIEFuIGFnZ3JlZ2F0ZSBudW1iZXIuXG4gICAqL1xuICBDT1VOVCA9ICdjb3VudCcsXG59XG5cbi8qKlxuICogVGhlIEV4ZWN1dGlvbkNsYXNzIHdoZXRoZXIgdGhlIGpvYiBpcyBydW4gd2l0aCBhIHN0YW5kYXJkIG9yIGZsZXhpYmxlIGV4ZWN1dGlvbiBjbGFzcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nbHVlL2xhdGVzdC9kZy9hd3MtZ2x1ZS1hcGktam9icy1qb2IuaHRtbCNhd3MtZ2x1ZS1hcGktam9icy1qb2ItSm9iXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9nbHVlL2xhdGVzdC9kZy9hZGQtam9iLmh0bWxcbiAqL1xuZXhwb3J0IGVudW0gRXhlY3V0aW9uQ2xhc3Mge1xuICAvKipcbiAgICogVGhlIGZsZXhpYmxlIGV4ZWN1dGlvbiBjbGFzcyBpcyBhcHByb3ByaWF0ZSBmb3IgdGltZS1pbnNlbnNpdGl2ZSBqb2JzIHdob3NlIHN0YXJ0XG4gICAqIGFuZCBjb21wbGV0aW9uIHRpbWVzIG1heSB2YXJ5LlxuICAgKi9cbiAgRkxFWCA9ICdGTEVYJyxcblxuICAvKipcbiAgICogVGhlIHN0YW5kYXJkIGV4ZWN1dGlvbiBjbGFzcyBpcyBpZGVhbCBmb3IgdGltZS1zZW5zaXRpdmUgd29ya2xvYWRzIHRoYXQgcmVxdWlyZSBmYXN0IGpvYlxuICAgKiBzdGFydHVwIGFuZCBkZWRpY2F0ZWQgcmVzb3VyY2VzLlxuICAgKi9cbiAgU1RBTkRBUkQgPSAnU1RBTkRBUkQnLFxufVxuXG4vKipcbiAqIEFXUyBHbHVlIHZlcnNpb24gZGV0ZXJtaW5lcyB0aGUgdmVyc2lvbnMgb2YgQXBhY2hlIFNwYXJrIGFuZCBQeXRob24gdGhhdCBhcmUgYXZhaWxhYmxlIHRvIHRoZSBqb2IuXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vZ2x1ZS9sYXRlc3QvZGcvYWRkLWpvYi5odG1sLlxuICovXG5leHBvcnQgZW51bSBHbHVlVmVyc2lvbiB7XG4gIC8qKlxuICAgKiBHbHVlIHZlcnNpb24gdXNpbmcgU3BhcmsgMi4yLjEgYW5kIFB5dGhvbiAyLjdcbiAgICovXG4gIFYwXzkgPSAnMC45JyxcblxuICAvKipcbiAgICogR2x1ZSB2ZXJzaW9uIHVzaW5nIFNwYXJrIDIuNC4zLCBQeXRob24gMi43IGFuZCBQeXRob24gMy42XG4gICAqL1xuICBWMV8wID0gJzEuMCcsXG5cbiAgLyoqXG4gICAqIEdsdWUgdmVyc2lvbiB1c2luZyBTcGFyayAyLjQuMyBhbmQgUHl0aG9uIDMuN1xuICAgKi9cbiAgVjJfMCA9ICcyLjAnLFxuXG4gIC8qKlxuICAgKiBHbHVlIHZlcnNpb24gdXNpbmcgU3BhcmsgMy4xLjEgYW5kIFB5dGhvbiAzLjdcbiAgICovXG4gIFYzXzAgPSAnMy4wJyxcblxuICAvKipcbiAgICogR2x1ZSB2ZXJzaW9uIHVzaW5nIFNwYXJrIDMuMy4wIGFuZCBQeXRob24gMy4xMFxuICAgKi9cbiAgVjRfMCA9ICc0LjAnLFxuXG4gIC8qKlxuICAgKiBHbHVlIHZlcnNpb24gdXNpbmcgU3BhcmsgMy41LjIgYW5kIFB5dGhvbiAzLjExXG4gICAqL1xuICBWNV8wID0gJzUuMCcsXG5cbn1cblxuLyoqXG4gKiBSdW50aW1lIGxhbmd1YWdlIG9mIHRoZSBHbHVlIGpvYlxuICovXG5leHBvcnQgZW51bSBKb2JMYW5ndWFnZSB7XG4gIC8qKlxuICAgKiBTY2FsYVxuICAgKi9cbiAgU0NBTEEgPSAnc2NhbGEnLFxuXG4gIC8qKlxuICAgKiBQeXRob25cbiAgICovXG4gIFBZVEhPTiA9ICdweXRob24nLFxufVxuXG4vKipcbiAqIFB5dGhvbiB2ZXJzaW9uXG4gKi9cbmV4cG9ydCBlbnVtIFB5dGhvblZlcnNpb24ge1xuICAvKipcbiAgICogUHl0aG9uIDIgKHRoZSBleGFjdCB2ZXJzaW9uIGRlcGVuZHMgb24gR2x1ZVZlcnNpb24gYW5kIEpvYkNvbW1hbmQgdXNlZClcbiAgICovXG4gIFRXTyA9ICcyJyxcblxuICAvKipcbiAgICogUHl0aG9uIDMgKHRoZSBleGFjdCB2ZXJzaW9uIGRlcGVuZHMgb24gR2x1ZVZlcnNpb24gYW5kIEpvYkNvbW1hbmQgdXNlZClcbiAgICovXG4gIFRIUkVFID0gJzMnLFxuXG4gIC8qKlxuICAgKiBQeXRob24gMy45ICh0aGUgZXhhY3QgdmVyc2lvbiBkZXBlbmRzIG9uIEdsdWVWZXJzaW9uIGFuZCBKb2JDb21tYW5kIHVzZWQpXG4gICAqL1xuICBUSFJFRV9OSU5FID0gJzMuOScsXG5cbn1cblxuLyoqXG4gKiBBV1MgR2x1ZSBydW50aW1lIGRldGVybWluZXMgdGhlIHJ1bnRpbWUgZW5naW5lIG9mIHRoZSBqb2IuXG4gKlxuICovXG5leHBvcnQgZW51bSBSdW50aW1lIHtcbiAgLyoqXG4gICAqIFJ1bnRpbWUgZm9yIGEgR2x1ZSBmb3IgUmF5IDIuNC5cbiAgICovXG4gIFJBWV9UV09fRk9VUiA9ICdSYXkyLjQnLFxufVxuXG4vKipcbiAqIFRoZSBqb2IgdHlwZS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byB1c2UgYSBKb2JUeXBlIHRoYXQgZG9lc24ndCBleGlzdCBhcyBhIHN0YXRpYyBtZW1iZXIsIHlvdVxuICogY2FuIGluc3RhbnRpYXRlIGEgYEpvYlR5cGVgIG9iamVjdCwgZS5nOiBgSm9iVHlwZS5vZignb3RoZXIgbmFtZScpYC5cbiAqL1xuZXhwb3J0IGVudW0gSm9iVHlwZSB7XG4gIC8qKlxuICAgKiBDb21tYW5kIGZvciBydW5uaW5nIGEgR2x1ZSBTcGFyayBqb2IuXG4gICAqL1xuICBFVEwgPSAnZ2x1ZWV0bCcsXG5cbiAgLyoqXG4gICAqIENvbW1hbmQgZm9yIHJ1bm5pbmcgYSBHbHVlIFNwYXJrIHN0cmVhbWluZyBqb2IuXG4gICAqL1xuICBTVFJFQU1JTkcgPSAnZ2x1ZXN0cmVhbWluZycsXG5cbiAgLyoqXG4gICAqIENvbW1hbmQgZm9yIHJ1bm5pbmcgYSBHbHVlIHB5dGhvbiBzaGVsbCBqb2IuXG4gICAqL1xuICBQWVRIT05fU0hFTEwgPSAncHl0aG9uc2hlbGwnLFxuXG4gIC8qKlxuICAgKiBDb21tYW5kIGZvciBydW5uaW5nIGEgR2x1ZSBSYXkgam9iLlxuICAgKi9cbiAgUkFZID0gJ2dsdWVyYXknLFxuXG59XG5cbi8qKlxuICogVGhlIG51bWJlciBvZiBBV1MgR2x1ZSBkYXRhIHByb2Nlc3NpbmcgdW5pdHMgKERQVXMpIHRoYXQgY2FuIGJlIGFsbG9jYXRlZCB3aGVuIHRoaXMgam9iIHJ1bnMuIEEgRFBVIGlzIGEgcmVsYXRpdmUgbWVhc3VyZSBvZiBwcm9jZXNzaW5nIHBvd2VyIHRoYXQgY29uc2lzdHMgb2YgNCB2Q1BVcyBvZiBjb21wdXRlIGNhcGFjaXR5IGFuZCAxNiBHQiBvZiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBlbnVtIE1heENhcGFjaXR5IHtcbiAgLyoqXG4gICAqIERQVSB2YWx1ZSBvZiAxLzE2dGhcbiAgICovXG4gIERQVV8xXzE2VEggPSAwLjA2MjUsXG5cbiAgLyoqXG4gICAqIERQVSB2YWx1ZSBvZiAxXG4gICAqL1xuICBEUFVfMSA9IDEsXG59XG5cbi8qXG4gKiBSZXByZXNlbnRzIHRoZSBsb2dpY2FsIG9wZXJhdG9yIGZvciBjb21iaW5pbmcgbXVsdGlwbGUgY29uZGl0aW9ucyBpbiB0aGUgR2x1ZSBUcmlnZ2VyIEFQSS5cbiAqL1xuZXhwb3J0IGVudW0gUHJlZGljYXRlTG9naWNhbCB7XG4gIC8qKlxuICAgKiBBbGwgY29uZGl0aW9ucyBtdXN0IGJlIHRydWUgZm9yIHRoZSBwcmVkaWNhdGUgdG8gYmUgdHJ1ZS5cbiAgICovXG4gIEFORCA9ICdBTkQnLFxuXG4gIC8qKlxuICAgKiBBdCBsZWFzdCBvbmUgY29uZGl0aW9uIG11c3QgYmUgdHJ1ZSBmb3IgdGhlIHByZWRpY2F0ZSB0byBiZSB0cnVlLlxuICAgKi9cbiAgQU5ZID0gJ0FOWScsXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgbG9naWNhbCBvcGVyYXRvciBmb3IgZXZhbHVhdGluZyBhIHNpbmdsZSBjb25kaXRpb24gaW4gdGhlIEdsdWUgVHJpZ2dlciBBUEkuXG4gKi9cbmV4cG9ydCBlbnVtIENvbmRpdGlvbkxvZ2ljYWxPcGVyYXRvciB7XG4gIC8qKiBUaGUgY29uZGl0aW9uIGlzIHRydWUgaWYgdGhlIHZhbHVlcyBhcmUgZXF1YWwuICovXG4gIEVRVUFMUyA9ICdFUVVBTFMnLFxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIGEgY3Jhd2xlciBmb3IgYSBjb25kaXRpb24gaW4gdGhlIEdsdWUgVHJpZ2dlciBBUEkuXG4gKi9cbmV4cG9ydCBlbnVtIENyYXdsZXJTdGF0ZSB7XG4gIC8qKiBUaGUgY3Jhd2xlciBpcyBjdXJyZW50bHkgcnVubmluZy4gKi9cbiAgUlVOTklORyA9ICdSVU5OSU5HJyxcblxuICAvKiogVGhlIGNyYXdsZXIgaXMgaW4gdGhlIHByb2Nlc3Mgb2YgYmVpbmcgY2FuY2VsbGVkLiAqL1xuICBDQU5DRUxMSU5HID0gJ0NBTkNFTExJTkcnLFxuXG4gIC8qKiBUaGUgY3Jhd2xlciBoYXMgYmVlbiBjYW5jZWxsZWQuICovXG4gIENBTkNFTExFRCA9ICdDQU5DRUxMRUQnLFxuXG4gIC8qKiBUaGUgY3Jhd2xlciBoYXMgY29tcGxldGVkIGl0cyBvcGVyYXRpb24gc3VjY2Vzc2Z1bGx5LiAqL1xuICBTVUNDRUVERUQgPSAnU1VDQ0VFREVEJyxcblxuICAvKiogVGhlIGNyYXdsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSBpdHMgb3BlcmF0aW9uLiAqL1xuICBGQUlMRUQgPSAnRkFJTEVEJyxcblxuICAvKiogVGhlIGNyYXdsZXIgZW5jb3VudGVyZWQgYW4gZXJyb3IgZHVyaW5nIGl0cyBvcGVyYXRpb24uICovXG4gIEVSUk9SID0gJ0VSUk9SJyxcbn1cbiJdfQ==