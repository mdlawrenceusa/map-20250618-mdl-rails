const AWS = require('aws-sdk');
const s3 = new AWS.S3();

const OUTPUT_BUCKET = process.env.OUTPUT_BUCKET;

exports.handler = async (event) => {
    console.log('Starting Rails seeds.rb generator');
    
    try {
        // Get the latest processed files from S3
        const listParams = {
            Bucket: OUTPUT_BUCKET,
            Prefix: 'processed/',
            MaxKeys: 1000
        };
        
        const listResult = await s3.listObjectsV2(listParams).promise();
        
        if (!listResult.Contents || listResult.Contents.length === 0) {
            throw new Error('No processed files found in output bucket');
        }
        
        // Find the most recent leads.json file
        const sortedFiles = listResult.Contents
            .filter(obj => obj.Key.endsWith('leads.json'))
            .sort((a, b) => b.LastModified - a.LastModified);
        
        if (sortedFiles.length === 0) {
            throw new Error('No leads.json file found');
        }
        
        const latestFile = sortedFiles[0];
        console.log(`Processing file: ${latestFile.Key}`);
        
        // Read all JSON parts (Spark might create multiple part files)
        const dirPath = latestFile.Key.substring(0, latestFile.Key.lastIndexOf('/') + 1);
        const dirListParams = {
            Bucket: OUTPUT_BUCKET,
            Prefix: dirPath
        };
        
        const dirContents = await s3.listObjectsV2(dirListParams).promise();
        const jsonFiles = dirContents.Contents.filter(obj => 
            obj.Key.endsWith('.json') && !obj.Key.includes('_SUCCESS')
        );
        
        // Read and merge all JSON files
        let allLeads = [];
        
        for (const file of jsonFiles) {
            const getParams = {
                Bucket: OUTPUT_BUCKET,
                Key: file.Key
            };
            
            const fileContent = await s3.getObject(getParams).promise();
            const lines = fileContent.Body.toString().trim().split('\n');
            
            for (const line of lines) {
                if (line.trim()) {
                    try {
                        const lead = JSON.parse(line);
                        allLeads.push(lead);
                    } catch (e) {
                        console.warn(`Failed to parse line: ${line.substring(0, 100)}...`);
                    }
                }
            }
        }
        
        console.log(`Found ${allLeads.length} leads to convert`);
        
        // Generate seeds.rb content
        let seedsContent = `# Generated by ETL Pipeline on ${new Date().toISOString()}\n`;
        seedsContent += `# Total leads: ${allLeads.length}\n\n`;
        seedsContent += `# Clear existing leads (optional - comment out if you want to append)\n`;
        seedsContent += `# Lead.destroy_all\n\n`;
        seedsContent += `leads_data = [\n`;
        
        // Convert each lead to Ruby hash format
        allLeads.forEach((lead, index) => {
            seedsContent += `  {\n`;
            seedsContent += `    name: ${rubyString(lead.name)},\n`;
            seedsContent += `    company: ${rubyString(lead.company)},\n`;
            seedsContent += `    phone: ${rubyString(lead.phone)},\n`;
            seedsContent += `    website: ${rubyString(lead.website)},\n`;
            seedsContent += `    state_province: ${rubyString(lead.state_province)},\n`;
            seedsContent += `    lead_source: ${rubyString(lead.lead_source || 'web')},\n`;
            seedsContent += `    email: ${rubyString(lead.email)},\n`;
            seedsContent += `    lead_status: ${rubyString(lead.lead_status || 'Open - Not Contacted')},\n`;
            
            // Handle date parsing
            if (lead.created_date) {
                seedsContent += `    created_date: DateTime.parse('${lead.created_date}'),\n`;
            } else {
                seedsContent += `    created_date: DateTime.now,\n`;
            }
            
            seedsContent += `    owner_alias: ${rubyString(lead.owner_alias || 'MDL')},\n`;
            seedsContent += `    unread_by_owner: ${lead.unread_by_owner === true ? 'true' : 'false'}\n`;
            seedsContent += `  }${index < allLeads.length - 1 ? ',' : ''}\n`;
        });
        
        seedsContent += `]\n\n`;
        seedsContent += `# Create leads in batches for better performance\n`;
        seedsContent += `puts "Creating #{leads_data.length} leads..."\n`;
        seedsContent += `created_count = 0\n`;
        seedsContent += `error_count = 0\n\n`;
        seedsContent += `leads_data.each_slice(100) do |batch|\n`;
        seedsContent += `  begin\n`;
        seedsContent += `    Lead.create!(batch)\n`;
        seedsContent += `    created_count += batch.length\n`;
        seedsContent += `    print "."\n`;
        seedsContent += `  rescue => e\n`;
        seedsContent += `    puts "\\nError creating batch: #{e.message}"\n`;
        seedsContent += `    # Try individual creates for this batch\n`;
        seedsContent += `    batch.each do |lead_attrs|\n`;
        seedsContent += `      begin\n`;
        seedsContent += `        Lead.create!(lead_attrs)\n`;
        seedsContent += `        created_count += 1\n`;
        seedsContent += `      rescue => individual_error\n`;
        seedsContent += `        puts "Failed to create lead: #{lead_attrs[:phone]} - #{individual_error.message}"\n`;
        seedsContent += `        error_count += 1\n`;
        seedsContent += `      end\n`;
        seedsContent += `    end\n`;
        seedsContent += `  end\n`;
        seedsContent += `end\n\n`;
        seedsContent += `puts "\\nCompleted! Created #{created_count} leads. Errors: #{error_count}"\n`;
        
        // Write seeds.rb to S3
        const timestamp = new Date().toISOString().replace(/:/g, '-');
        const seedsKey = `rails-seeds/${timestamp}/seeds.rb`;
        
        await s3.putObject({
            Bucket: OUTPUT_BUCKET,
            Key: seedsKey,
            Body: seedsContent,
            ContentType: 'text/plain'
        }).promise();
        
        console.log(`Generated seeds.rb with ${allLeads.length} leads`);
        
        // Also generate a smaller sample seeds file for testing
        const sampleLeads = allLeads.slice(0, 25);
        let sampleSeedsContent = `# Sample seeds.rb - First 25 leads for testing\n`;
        sampleSeedsContent += `# Generated on ${new Date().toISOString()}\n\n`;
        sampleSeedsContent += `Lead.create!([\n`;
        
        sampleLeads.forEach((lead, index) => {
            sampleSeedsContent += `  {\n`;
            sampleSeedsContent += `    name: ${rubyString(lead.name)},\n`;
            sampleSeedsContent += `    company: ${rubyString(lead.company)},\n`;
            sampleSeedsContent += `    phone: ${rubyString(lead.phone)},\n`;
            sampleSeedsContent += `    website: ${rubyString(lead.website)},\n`;
            sampleSeedsContent += `    state_province: ${rubyString(lead.state_province)},\n`;
            sampleSeedsContent += `    lead_source: ${rubyString(lead.lead_source || 'web')},\n`;
            sampleSeedsContent += `    email: ${rubyString(lead.email)},\n`;
            sampleSeedsContent += `    lead_status: ${rubyString(lead.lead_status || 'Open - Not Contacted')},\n`;
            
            if (lead.created_date) {
                sampleSeedsContent += `    created_date: DateTime.parse('${lead.created_date}'),\n`;
            } else {
                sampleSeedsContent += `    created_date: DateTime.now,\n`;
            }
            
            sampleSeedsContent += `    owner_alias: ${rubyString(lead.owner_alias || 'MDL')},\n`;
            sampleSeedsContent += `    unread_by_owner: ${lead.unread_by_owner === true ? 'true' : 'false'}\n`;
            sampleSeedsContent += `  }${index < sampleLeads.length - 1 ? ',' : ''}\n`;
        });
        
        sampleSeedsContent += `])\n`;
        
        const sampleSeedsKey = `rails-seeds/${timestamp}/sample_seeds.rb`;
        await s3.putObject({
            Bucket: OUTPUT_BUCKET,
            Key: sampleSeedsKey,
            Body: sampleSeedsContent,
            ContentType: 'text/plain'
        }).promise();
        
        return {
            statusCode: 200,
            body: JSON.stringify({
                message: 'Rails seeds.rb generated successfully',
                summary: {
                    totalLeads: allLeads.length,
                    seedsLocation: `s3://${OUTPUT_BUCKET}/${seedsKey}`,
                    sampleSeedsLocation: `s3://${OUTPUT_BUCKET}/${sampleSeedsKey}`
                }
            })
        };
        
    } catch (error) {
        console.error('Error generating seeds.rb:', error);
        throw error;
    }
};

function rubyString(value) {
    if (value === null || value === undefined || value === '') {
        return "''";
    }
    // Escape single quotes and wrap in single quotes
    const escaped = String(value).replace(/'/g, "\\'");
    return `'${escaped}'`;
}